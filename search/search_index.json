{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Integrantes de equipo:","text":""},{"location":"#1-abraham-dominguez-noda","title":"1.- Abraham Dom\u00ednguez Noda","text":""},{"location":"#descripcion-personal","title":"Descripci\u00f3n personal","text":"<ul> <li>\u00bfQui\u00e9n soy?<ul> <li>Me llamo Abraham Dom\u00ednguez Noda, tengo 17 a\u00f1os</li> </ul> </li> <li>Lugar de origen:<ul> <li>Vengo del Estado de M\u00e9xico</li> </ul> </li> <li>Intereses<ul> <li>Me gusta la tecnolog\u00eda</li> </ul> </li> <li>\u00bfDe que me enorgullezco?<ul> <li>Estoy orgulloso de haber hecho sin ayuda nada m\u00e1s que de TikTok, haber hecho un circuito con focos leds que tengan la funcion de ser unas direccionales, intermitentes, faros, altas y calaberas; adem\u00e1s le puse un motor electrico ya que este solo contaba con uno \"Pull and back\".</li> </ul> </li> <li>\u00bfQu\u00e9 estudio?<ul> <li>Ingenieria Mecatr\u00f3nica.</li> </ul> </li> <li>Me puedes localizar en: 203599@iberopuebla.mx</li> </ul>"},{"location":"#2-jose-gil-gonzalez-berra","title":"2.-Jos\u00e9 Gil Gonz\u00e1lez Berra","text":""},{"location":"#descripcion-personal_1","title":"Descripci\u00f3n personal","text":"<ul> <li>\u00bfQui\u00e9n soy?<ul> <li>Me llam\u00f3 Jos\u00e9 Gil Gonz\u00e1lez Berra, tengo 17 a\u00f1os </li> </ul> </li> <li>Lugar de origen:<ul> <li>Tabasco</li> </ul> </li> <li>Intereses<ul> <li>Me gusta la tecnolog\u00eda</li> <li>Me gustan los videojuegos</li> <li>Mi deporte favorito es el futbol</li> </ul> </li> <li>\u00bfDe que me enorgullezco?<ul> <li>Tener un promedio de 9.8 de preparatoria</li> <li>De estar en la IBERO</li> </ul> </li> <li> <p>\u00bfQu\u00e9 estudio?</p> <ul> <li>Ingenieria Mecatr\u00f3nica.</li> </ul> </li> <li> <p>Me puedes localizar en: 203536@iberopuebla.mx</p> </li> </ul>"},{"location":"Practicas/","title":"Practicas de clase","text":""},{"location":"Practicas/#practica-1-encendido-de-led","title":"Practica 1 - Encendido de LED","text":""},{"location":"Practicas/#introduccion","title":"Introduccion","text":"<p>La pr\u00e1ctica se enmarc\u00f3 dentro de la materia de Introducci\u00f3n a la Mecatr\u00f3nica y tuvo como finalidad el estudio y la aplicaci\u00f3n del circuito integrado temporizador 555. El manejo de temporizadores y la generaci\u00f3n de se\u00f1ales de reloj son fundamentales para el dise\u00f1o de sistemas de control y automatizaci\u00f3n.</p> <ul> <li>Los objetivos principales de esta pr\u00e1ctica fueron:</li> </ul> <p>Comprender el principio de funcionamiento del circuito integrado 555 en su configuraci\u00f3n astable.  * Dise\u00f1ar e implementar un circuito intermitente capaz de controlar el encendido y apagado de un LED.  * Calcular y ajustar los componentes pasivos R_1, R_2 y C_1 para lograr un periodo de oscilaci\u00f3n total (T) entre 1 y 5 segundos.</p>"},{"location":"Practicas/#marco-teorico","title":"Marco Teorico","text":"<p>Circuito Integrado 555 (Modo Astable):</p> <p>El 555 en modo astable opera como un multivibrador auto-oscilante, lo que significa que su salida (Pin 3) conmuta continuamente entre el estado ALTO y BAJO sin necesidad de una entrada externa. El tiempo que permanece en cada estado lo define la carga y descarga del capacitor a trav\u00e9s de las resistencias.</p> <p>F\u00f3rmulas de C\u00e1lculo y Componentes:</p> <p>El dise\u00f1o se basa en las siguientes ecuaciones, donde los valores utilizados son: </p> <ul> <li>R1 = 1 k Omega</li> <li>R2 = 35 k Omega</li> <li>C1 = 100 mu F</li> </ul> <p>Formulas:</p> <ul> <li>Tiempo de Apagado: 0.693 (R_2) (C_1)</li> <li>Tiempo de Encendido: 0.693 (R_1 + R_2)  (C_1)</li> <li>Per\u00edodo Total: 0.693(R_1 + 2R_2) (C_1(</li> </ul>"},{"location":"Practicas/#procedimiento","title":"Procedimiento","text":"<ul> <li>Materiales y Equipo</li> <li>Circuito Integrado 555</li> <li>LED </li> <li>Resistencias de 1 y de 35</li> <li>Capacitor de 100 Mu F</li> <li>Fuente de alimentaci\u00f3n (VCC).</li> <li>Protoboard y cables de conexi\u00f3n.</li> <li>Osciloscopio y/o cron\u00f3metro (para verificaci\u00f3n).</li> </ul> <p>Procedimiento de Montaje</p> <p>1.- C\u00e1lculo: Se verific\u00f3 el valor te\u00f3rico del per\u00edodo con los componentes seleccionados, obteniendo $T \\approx \\mathbf{4.92 \\text{ segundos}}$.</p> <p>2.-Cableado del CI: El CI 555 se coloc\u00f3 en la protoboard. Los Pines 8 (VCC) y 4 (Reset) se conectaron a VCC y los Pines 1 (GND) y 5 (Control) se conectaron a tierra.</p> <p>3.- Red RC (Temporizaci\u00f3n):</p> <ul> <li> <p>R_1 kOmega se conect\u00f3 entre VCC y el Pin 7 (Discharge).</p> </li> <li> <p>R_2 35 kOmega se conect\u00f3 entre el Pin 7 y los Pines 6 y 2 (unidos).</p> </li> <li> <p>C_1 100 mu F se conect\u00f3 desde los Pines 6/2 a tierra.</p> </li> </ul> <p>4.- Salida: El Pin 3 (Output) se conect\u00f3 a la resistencia limitadora R_3 1 kOmega, y esta al \u00e1nodo del LED, cuyo c\u00e1todo fue a tierra.</p> <p>5.-Verificaci\u00f3n: Se aplic\u00f3 la fuente de alimentaci\u00f3n para observar el parpadeo del LED y se utiliz\u00f3 el osciloscopio para medir el per\u00edodo de la se\u00f1al.</p>"},{"location":"Practicas/#resultados","title":"Resultados","text":"<ul> <li> <p>Tiempo de Apagado: 2.43 segundos</p> </li> <li> <p>Tiempo de Encendido: 2.49 segundos</p> </li> <li> <p>Per\u00edodo Total: 4.92 segundos</p> </li> </ul>"},{"location":"Practicas/#conclusion","title":"Conclusion","text":"<p>La pr\u00e1ctica fue exitosa al implementar el oscilador Astable utilizando el CI 555 y demostr\u00f3 la capacidad de controlar el tiempo de un circuito anal\u00f3gico mediante la correcta selecci\u00f3n de la red RC. El uso de $R_2 = 35 kOmega y $C_1 = 100 mu F produjo un parpadeo lento con un per\u00edodo cercano a 2 segundos entre encendido y apagado.</p> <p></p> <p>Video de Encendio del Led</p>"},{"location":"Practicas/#practica-2-encendido-y-apagado-de-led-con-esp32","title":"Practica 2 - Encendido y apagado de LED con ESP32","text":""},{"location":"Practicas/#introduccion_1","title":"Introduccion","text":"<p>Esta pr\u00e1ctica es fundamental en la introducci\u00f3n a los sistemas embebidos y la Mecatr\u00f3nica. Se centra en el control digital m\u00e1s b\u00e1sico: el manejo de una salida (output) mediante un microcontrolador. Se utiliz\u00f3 el ESP32 para controlar directamente un Diodo Emisor de Luz (LED), confirmando el correcto funcionamiento de los pines.</p> <p>Los objetivos principales de esta pr\u00e1ctica fueron:</p> <ul> <li>Establecer la comunicaci\u00f3n y programaci\u00f3n del microcontrolador ESP32.</li> <li>Implementar un control digital ON/OFF (encendido y apagado) para el estado del LED.</li> </ul>"},{"location":"Practicas/#marco-teorico_1","title":"Marco Teorico","text":"<p>Microcontrolador ESP32El </p> <p>ESP32 es la placa de desarrollo utilizada para alojar y ejecutar el c\u00f3digo de control. Sus pines de GPIO (General-Purpose Input/Output) pueden ser configurados para funcionar como salidas que aplican un voltaje (estado ALTO, generalmente 3.3 o 0 (estado BAJO).</p> <p>Control Digital ON/OFF</p> <p>El LED se controla mediante una l\u00f3gica digital simple:</p> <p>Estado ALTO (1): El pin GPIO suministra voltaje, y el LED se enciende. Estado BAJO (0): El pin GPIO se pone a $0 , y el LED se apaga.</p> <p>Funciones Clave</p> <p>El c\u00f3digo utiliza tres funciones principales del entorno de Arduino:</p> <p><code>pinMode(pin, OUTPUT)</code>: Configura el pin seleccionado (led = 13) para que funcione como una salida de voltaje.</p> <p><code>digitalWrite(pin, value)</code>: Env\u00eda una se\u00f1al digital (ALTO o BAJO) al pin.</p> <p><code>delay(ms)</code>: Pausa la ejecuci\u00f3n del c\u00f3digo por el n\u00famero de milisegundos (ms) especificado, estableciendo la temporizaci\u00f3n del parpadeo.</p>"},{"location":"Practicas/#procedimiento_1","title":"Procedimiento","text":"<p>Materiales y Equipo   * Microcontrolador ESP32   * LED   * Resistencias   * Cables Jumpers   * Protoboards   * Computadora con IDE de Arduino</p> <p>Procedimiento para conexion</p> <p>1.- Se conect\u00f3 el pin \u00e1nodo (pata larga) del LED al pin GPIO 13 del ESP32, en serie con la resistencia limitadora.</p> <p>2.- El c\u00e1todo (pata corta) del LED se conect\u00f3 a la l\u00ednea de tierra (GND) del ESP32.</p> <p>3.- Subimos el codigo a la ESP32</p> <pre><code>const int led = 13;\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(led, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(led, 1);\n  delay(1000);\n  digitalWrite(led, 0);\n  delay(1000);\n}\n</code></pre>"},{"location":"Practicas/#resultados_1","title":"Resultados","text":"<p>La actividad fue completamente exitosa y demostr\u00f3 el control digital del microcontrolador.</p> <ul> <li>Comportamiento Observado: El LED comenz\u00f3 a parpadear de forma r\u00edtmica e ininterrumpida tan pronto como se carg\u00f3 el c\u00f3digo.</li> <li>Temporizaci\u00f3n: El tiempo de encendido fue de $\\mathbf{1}$ segundo y el tiempo de apagado fue de 1 segundo, cumpliendo con la temporizaci\u00f3n programada en el c\u00f3digo.</li> </ul>"},{"location":"Practicas/#conclusion_1","title":"Conclusion","text":"<p>Concluy\u00f3 con \u00e9xito, demostrando el control esencial de las salidas digitales del ESP32. Se logr\u00f3 programar un parpadeo intermitente con un periodo de 2 segundos (1 s encendido, 1 s apagado). El principal aprendizaje fue la correcta aplicaci\u00f3n de pinMode() para la configuraci\u00f3n y digitalWrite() para la conmutaci\u00f3n de estados</p> <p>Video de Encendio del Led</p> <p>Nota</p> <p>Disculpe la falta de fotos, esa semana tuve un probelma y me robaron el celular y no pude tomar fotos</p>"},{"location":"Practicas/#practica-3-encendido-de-led-con-esp32-y-un-boton","title":"Practica 3- Encendido de LED con ESP32 y un bot\u00f3n","text":""},{"location":"Practicas/#introduccion_2","title":"Introducci\u00f3n","text":"<p>El objetivo fue establecer la comunicaci\u00f3n bidireccional entre el ESP32 y el mundo exterior, utilizando un bot\u00f3n pulsador como entrada digital para gestionar directamente el estado de un LED como salida.</p> <p>Objetivos</p> <p>Los objetivos principales de esta actividad fueron:</p> <ul> <li>Configurar un pin del ESP32 como entrada para leer el estado del bot\u00f3n.</li> <li>Configurar otro pin como salida para controlar el LED.</li> <li>Implementar la l\u00f3gica de control para que el LED se encienda \u00fanicamente cuando se detecte la pulsaci\u00f3n del bot\u00f3n (estado ALTO).</li> </ul>"},{"location":"Practicas/#marco-teorico_2","title":"Marco Teorico","text":"<p>Microcontrolador ESP32</p> <p>El ESP32 es el sistema de control que aloja el c\u00f3digo. El n\u00facleo de la pr\u00e1ctica es el manejo de los pines GPIO (Entrada/Salida de Prop\u00f3sito General), que pueden ser configurados de dos formas:</p> <ul> <li>Salida (OUTPUT): Env\u00eda una se\u00f1al (voltaje) para controlar el LED.</li> <li>Entrada (INPUT): Lee el voltaje aplicado externamente por el bot\u00f3n.</li> </ul> <p>Bot\u00f3n Pulsador y Resistencia Pull-down</p> <p>El Bot\u00f3n Pulsador act\u00faa como un interruptor. Al ser presionado, conecta el pin de entrada (GPIO 34) a la fuente de voltaje ($3.3 \\text{V}$), lo que genera la se\u00f1al ALTO (1) que el ESP32 debe leer. Idealmente, se usa una resistencia pull-down para asegurar que el pin siempre lea BAJO (0) cuando el bot\u00f3n est\u00e1 liberado, evitando lecturas err\u00f3neas.</p>"},{"location":"Practicas/#procedimiento_2","title":"Procedimiento","text":"<p>Materiales</p> <ul> <li>Microcontrolador ESP32</li> <li>LED</li> <li>Resistencia limitadora (para el LED)</li> <li>Resistencia Pull Down </li> <li>Bot\u00f3n Pulsador de cuatro patas.</li> <li>Cables Jumper</li> <li>Protoboard.</li> <li>Computadora con Arduino IDE </li> </ul> <p>Procedimiento de la conexion</p> <p>1.- Conexi\u00f3n del LED: </p> <p>-El LED se conecta al pin 33, con su resistencia limitadora a GND.</p> <p>2.- Conexi\u00f3n del Bot\u00f3n:</p> <ul> <li>Un terminal del bot\u00f3n se conecta al pin 34.</li> <li>Otro terminal del bot\u00f3n se conecta a la fuente de voltaje (3.3V).</li> <li>Se conecta una resistencia del pin  34 a Tierra (GND).</li> </ul> <p>3.- Generamos el codigo y se lo subimos a la ESP32:</p> <pre><code>const int led = 33;\nconst int btn = 34;\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(led, OUTPUT);\n  pinMode(btn, INPUT);\n}\n\nvoid loop() {\n  int estado = digitalRead(btn);\n  if (estado == 1) {\n    digitalWrite(led, 1);\n  } else {\n    digitalWrite(led, 0);\n  }\n}\n</code></pre>"},{"location":"Practicas/#resultados_2","title":"Resultados","text":"<p>La actividad fue exitosa, estableciendo un control directo y en tiempo real sobre el LED. El LED permaneci\u00f3 apagado mientras el bot\u00f3n estaba en reposo. Al presionar y mantener el bot\u00f3n, el LED se encendi\u00f3 de forma inmediata. Al soltar el bot\u00f3n, el LED se apag\u00f3 de forma instant\u00e1nea.</p>"},{"location":"Practicas/#conclusion_2","title":"Conclusion","text":"<p>La pr\u00e1ctica fue exitosa al implementar el control de un LED mediante una entrada digital, consolidando el uso del ESP32 para la interacci\u00f3n en tiempo real. Se demostr\u00f3 la capacidad de leer el estado de un interruptor <code>(digitalRead)</code> y usar esa informaci\u00f3n para controlar una salida <code>(digitalWrite)</code></p> <p>Video de Encendio del Led</p> <p>Nota</p> <p>Disculpe la falta de fotos, esa semana tuve un probelma y me robaron el celular y no pude tomar fotos</p>"},{"location":"Practicas/#practica-4-encendido-de-led-con-esp32-y-bluetooth","title":"Practica 4 - Encendido de Led con ESP32 y Bluetooth","text":""},{"location":"Practicas/#introduccion_3","title":"Introduccion","text":"<p>Esta pr\u00e1ctica marca la transici\u00f3n del control local (botones, temporizaci\u00f3n) al control remoto inal\u00e1mbrico, utilizando la capacidad nativa de Bluetooth del microcontrolador ESP32. El objetivo fue establecer una comunicaci\u00f3n serial a trav\u00e9s de Bluetooth para enviar comandos simples de texto  desde un dispositivo externo (como un smartphone) y gestionar remotamente el estado de un LED.</p>"},{"location":"Practicas/#marco-teorico_3","title":"Marco Teorico","text":"<p>Bluetooth Serial (SPP)</p> <p>El ESP32 soporta m\u00faltiples protocolos, incluyendo Bluetooth Cl\u00e1sico para la comunicaci\u00f3n Serial Profile (SPP). Esto permite que el ESP32 se comunique como un dispositivo de puerto serie virtual, siendo detectado y emparejado como un m\u00f3dulo Bluetooth tradicional (como el HC-05). La librer\u00eda BluetoothSerial.h facilita esta funcionalidad, permitiendo enviar y recibir datos como si fuera una conexi\u00f3n serial por cable.</p> <p>Comunicaci\u00f3n Inal\u00e1mbrica</p> <p>El control se basa en la recepci\u00f3n de datos sin contacto f\u00edsico.</p> <ul> <li> <p><code>SerialBT.begin()</code>: Asigna un nombre (en el c\u00f3digo, \"Abraham_ESP32\") para que el dispositivo sea visible y se pueda emparejar.</p> </li> <li> <p><code>SerialBT.available()</code>: Es la funci\u00f3n clave que verifica continuamente si hay comandos (datos) pendientes en el buffer de recepci\u00f3n inal\u00e1mbrico.</p> </li> <li> <p><code>SerialBT.readString()</code>: Lee la cadena de texto completa enviada por el dispositivo remoto (el comando).</p> </li> </ul>"},{"location":"Practicas/#procedimiento_3","title":"Procedimiento","text":"<p>Materiales</p> <ul> <li>Microcontrolador ESP32</li> <li>LED</li> <li>Resistencia limitadora.</li> <li>Cables Jumper</li> <li>Protoboard.</li> <li>Dispositivo Remoto: Un smartphone o computadora con capacidad Bluetooth y una aplicaci\u00f3n de terminal Serial Bluetooth para enviar los comandos</li> </ul> <p>Procedimiento de conexion de cables y programaci\u00f3n</p> <p>1.- Los cables se mantienen conectados de la misma manera que en la practica anterior, solo cambiamos el codigo</p> <p>2.- Generamos el codigo y lo subimos a la ESP32:</p> <p><pre><code>#include \"BluetoothSerial.h\"\nBluetoothSerial SerialBT;\n\nconst int led = 33;\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(\"AbrahamESP32\"); // Nombre del dispositivo Bluetooth\n  pinMode(led, OUTPUT);\n}\n\nvoid loop() {\n  if (SerialBT.available()) {\n    String mensaje = SerialBT.readString();\n    Serial.println(\"Recibido: \" + mensaje);\n\n    if (mensaje == \"ON\") {\n      digitalWrite(led, HIGH);\n    } else if (mensaje == \"OFF\") {\n      digitalWrite(led, LOW);\n    }\n  }\n  delay(100);\n}\n</code></pre> 3.- Con la aplicacion concetamos el celular via Bluetooth a la ESP32 y comprobamos que al escirbir \"ON\" se enciende y al escribir \"OFF\" se apaga el LED.</p>"},{"location":"Practicas/#resultados_3","title":"Resultados","text":"<p>Conectividad: </p> <p>El dispositivo \"AbrahamESP32\" fue detectado y se pudo establecer el emparejamiento desde el dispositivo remoto.</p> <p>Comportamiento del LED:</p> <ul> <li>Al enviar el mensaje exacto \"ON\" desde la terminal Bluetooth, el LED se encendi\u00f3.</li> <li>Al enviar el mensaje exacto \"OFF\", el LED se apag\u00f3.</li> <li>Cualquier otro comando o variaci\u00f3n de texto no gener\u00f3 ninguna acci\u00f3n, confirmando la sensibilidad del c\u00f3digo a la coincidencia exacta de la cadena de texto.</li> </ul>"},{"location":"Practicas/#conclusion_3","title":"Conclusion","text":"<p>Concluy\u00f3 exitosamente con la implementaci\u00f3n del control remoto de un LED mediante Bluetooth Serial en el ESP32. Se logr\u00f3 configurar el enlace inal\u00e1mbrico y demostrar la capacidad del microcontrolador para procesar comandos de texto recibidos por aire para manipular una salida digital.</p> <p>Video de Encendio del Led</p> <p>Nota</p> <p>Disculpe la falta de fotos, esa semana tuve un probelma y me robaron el celular y no pude tomar fotos</p>"},{"location":"Practicas/#practica-5-movimiento-de-motores-con-esp32","title":"Practica 5- Movimiento de motores con ESP32","text":""},{"location":"Practicas/#introduccion_4","title":"Introduccion","text":"<p>La pr\u00e1ctica tuvo como objetivo principal la integraci\u00f3n de un sistema embebido (ESP32) con un sistema de actuaci\u00f3n (motor DC) utilizando un m\u00f3dulo controlador Puente H. Esta pr\u00e1ctica es fundamental en el campo de la Mecatr\u00f3nica, ya que establece las bases para el control de movimiento y la direcci\u00f3n de actuadores en sistemas automatizados y rob\u00f3tica.</p> <ul> <li> <p>Objetivos:</p> </li> <li> <p>Los objetivos principales de esta pr\u00e1ctica fueron:</p> </li> <li>Establecer la comunicaci\u00f3n y el control de un motor de corriente continua (DC) mediante el microcontrolador ESP32 y un driver de motor.</li> <li>Implementar el control de direcci\u00f3n del motor, logrando que gire en un sentido, se detenga y luego gire en el sentido opuesto.</li> <li>Programar y controlar la temporizaci\u00f3n de cada estado de movimiento (avance, paro y reversa) utilizando funciones de retardo (delay).</li> </ul>"},{"location":"Practicas/#marco-teorico_4","title":"Marco Teorico","text":"<ul> <li> <p>Motores DC (Actuador):- El Motor de Corriente Continua (DC) es el componente que convierte la energ\u00eda el\u00e9ctrica en movimiento mec\u00e1nico. Su caracter\u00edstica esencial en esta pr\u00e1ctica es que su direcci\u00f3n de giro est\u00e1 determinada por la polaridad del voltaje que se le aplica a sus terminales.</p> </li> <li> <p>Driver de Motor (Puente H):- El circuito Puente H es un m\u00f3dulo de potencia indispensable que act\u00faa como intermediario. Su funci\u00f3n principal es doble: primero, suministrar la alta corriente necesaria para el motor utilizando una fuente externa (ya que el ESP32 no puede hacerlo); y segundo, controlar la direcci\u00f3n del motor. El Puente H invierte la polaridad del voltaje aplicado al motor seg\u00fan las se\u00f1ales l\u00f3gicas que recibe.</p> </li> <li> <p>Interconexi\u00f3n y Control L\u00f3gico:- La interconexi\u00f3n se establece utilizando los pines del ESP32 para enviar se\u00f1ales de control al Puente H. Espec\u00edficamente, dos pines del ESP32 (in1 e in2) se conectan a las entradas l\u00f3gicas del Puente H.</p> </li> </ul>"},{"location":"Practicas/#procedimiento_4","title":"Procedimiento","text":"<p>Materiales y Equipo</p> <ul> <li>Microcontrolador ESP32</li> <li>Motor de Corriente Continua</li> <li>M\u00f3dulo Puente H</li> <li>Protoboard</li> <li>Cables Jumper</li> <li>Fuente de Alimentaci\u00f3n Externa (para el motor)</li> <li>Computadora con IDE de Arduino</li> <li>Cable USB (para el ESP32)</li> </ul> <p>Procedimiento</p> <ul> <li>Montaje y Conexi\u00f3n del Hardware</li> </ul> <p>1.- Conexi\u00f3n del Driver de Potencia: Conecta los pines de control l\u00f3gico del Driver de Motor (Puente H) a los pines digitales del ESP32.  - Conectar el pin de entrada 1 del driver al pin 25 (in1).  - Conectar el pin de entrada 2 del driver al pin 26 (in2).</p> <p>2.- Conexi\u00f3n del Motor: Conectar las dos terminales del Motor DC a las terminales de salida del Driver de Motor.</p> <p>3.- Alimentaci\u00f3n: Conectar la fuente de alimentaci\u00f3n externa al pin de voltaje del Driver de Motor.  - Aseg\u00fararnos de que la tierra (GND) del ESP32 est\u00e9 conectada a la tierra (GND) del Driver de Motor y de la fuente externa (tierra com\u00fan).</p> <p>4.- Alimentaci\u00f3n L\u00f3gica: Conectar el ESP32 a la computadora mediante el cable USB para la alimentaci\u00f3n l\u00f3gica y la carga del c\u00f3digo.</p> <p>5.- Subimo el codigo a la ESP32</p> <pre><code>#define in1 25\n#define in2 26\n\nvoid setup() {\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n\n    digitalWrite(in1, 1); \n    digitalWrite(in2, 0); \n    delay(3000);\n    digitalWrite(in1, 0); \n    digitalWrite(in2, 0); \n    delay(1000);\n    digitalWrite(in1, 0); \n    digitalWrite(in2, 1); \n    delay(1000); \n  }\n</code></pre>"},{"location":"Practicas/#resultados_4","title":"Resultados","text":"<p>El circuito implementado con el ESP32 ejecut\u00f3 la secuencia programada, logrando el control de la direcci\u00f3n y la temporizaci\u00f3n del motor.</p> <ul> <li>Sentido 1 (Avance/Giro): El motor gir\u00f3 en la primera direcci\u00f3n durante 3 segundos (delay(3000)).</li> <li>Paro por Inercia: El motor se detuvo por completo por inercia durante 1 segundo (delay(1000)).</li> <li>Sentido 2 (Reversa/Contragiro): El motor gir\u00f3 en la direcci\u00f3n opuesta durante 1 segundo (delay(1000)).</li> </ul>"},{"location":"Practicas/#conclusion_4","title":"Conclusion","text":"<p>La pr\u00e1ctica fue exitosa al demostrar el control b\u00e1sico de direcci\u00f3n y temporizaci\u00f3n de un motor DC utilizando el ESP32 y un driver Puente H. Se logr\u00f3 controlar la direcci\u00f3n de giro y la duraci\u00f3n de cada estado (avance, paro y reversa) mediante los comandos digitalWrite() y delay(). Esto confirm\u00f3 la comprensi\u00f3n de la l\u00f3gica del driver y la capacidad del ESP32 para manejar la actuaci\u00f3n.</p> <p> </p> <p>Video de Encendidi de Motores con ESP32</p>"},{"location":"Practicas/#practica-6-aceleracion-y-desaceleracion-de-motores-con-esp32","title":"Practica 6 - Aceleracion y desaceleracion de motores con ESP32","text":""},{"location":"Practicas/#introduccion_5","title":"Introduccion","text":"<p>La Pr\u00e1ctica de Control de Velocidad con ESP32 tuvo como enfoque principal la aplicaci\u00f3n de la Modulaci\u00f3n por Ancho de Pulso (PWM) para lograr un control fino y gradual del movimiento de un motor de corriente continua (DC). El objetivo fue ir m\u00e1s all\u00e1 del control simple de encendido/apagado para implementar una variaci\u00f3n din\u00e1mica de la velocidad.</p> <ul> <li>Objetivos:</li> </ul> <p>Los objetivos principales de esta pr\u00e1ctica fueron:    - Configurar y utilizar el hardware de PWM del microcontrolador ESP32 para generar una se\u00f1al de velocidad.    - Implementar un algoritmo que permita al motor acelerar progresivamente hasta su velocidad m\u00e1xima.    - Implementar un algoritmo que, al alcanzar la velocidad m\u00e1xima o un umbral predefinido, inicie una desaceleraci\u00f3n o un cambio en la rampa de velocidad.</p>"},{"location":"Practicas/#marco-teorico_5","title":"Marco Teorico","text":"<ul> <li>Motores DC (Actuador):</li> </ul> <p>El Motor DC es el actuador cuya velocidad se controla. Su velocidad de rotaci\u00f3n es directamente proporcional al voltaje promedio que recibe. La direcci\u00f3n de giro se mantiene fija en esta pr\u00e1ctica mediante una polaridad constante.</p> <ul> <li>Driver de Motor (Puente H)</li> </ul> <p>El Driver de Motor (Puente H) es esencial para suministrar la alta corriente que el ESP32 no puede proveer. En esta pr\u00e1ctica, el Puente H cumple dos funciones:</p> <ul> <li>Control de Direcci\u00f3n: Los pines in1 y in2 se fijan en un estado l\u00f3gico (1 y 0) para mantener una direcci\u00f3n constante.</li> <li> <p>Control de Velocidad: El pin PWM del ESP32 se conecta al pin de Enable del driver para modular el voltaje promedio que llega al motor.</p> </li> <li> <p>Modulaci\u00f3n por Ancho de Pulso (PWM):</p> </li> </ul> <p>El PWM es la t\u00e9cnica central para el control de velocidad. El ESP32 utiliza la API ledc para generar una se\u00f1al digital cuyo ciclo de trabajo (el tiempo que la se\u00f1al est\u00e1 en ALTO) var\u00eda.</p> <ul> <li> <p>ledcAttachChannel(pin, freq, bits, channel): Inicializa un canal PWM. En el c\u00f3digo, la resoluci\u00f3n de 8 bits define que la velocidad var\u00eda de $0$ (apagado) a $255$ (m\u00e1ximo).</p> </li> <li> <p>ledcWrite(): Es la funci\u00f3n que establece el ciclo de trabajo, controlando directamente la velocidad del motor.</p> </li> </ul>"},{"location":"Practicas/#procedimiento_5","title":"Procedimiento","text":"<p>Materiales y Equipo</p> <ul> <li>Microcontrolador ESP32 </li> <li>Motor de Corriente Continua </li> <li>M\u00f3dulo Puente H</li> <li>Protoboard</li> <li>Cables Jumper</li> <li>Fuente de Alimentaci\u00f3n Externa (para el motor)</li> <li>Computadora con IDE de Arduino</li> <li>Cable USB (para el ESP32)</li> </ul> <p>Procedimiento</p> <ul> <li>Montaje y Conexi\u00f3n del Hardware</li> </ul> <p>1.- Conexi\u00f3n del Driver de Potencia: Conecta los pines de control l\u00f3gico del Driver de Motor (Puente H) a los pines digitales del ESP32.  - Conectar el pin de entrada 1 del driver a pin 32 (in1).  - Conectar el pin de entrada 2 del driver a pin 33 (in2).</p> <p>2.- Conexi\u00f3n del Motor: Conectar las dos terminales del Motor DC a las terminales de salida del Driver de Motor.</p> <p>3.- Conexi\u00f3n PWM: El pin 25 (definido impl\u00edcitamente por el canal 0 en ledcAttachChannel) o un pin equivalente (esto debe revisarse, ya que ledcWrite usa el n\u00famero de canal o el pin) se conecta al pin de Enable/Velocidad del driver.</p> <p>4.- Alimentaci\u00f3n: Conectar la fuente de alimentaci\u00f3n externa al pin de voltaje del Driver de Motor.  - Aseg\u00fararnos de que la tierra (GND) del ESP32 est\u00e9 conectada a la tierra (GND) del Driver de Motor y de la fuente externa (tierra com\u00fan).</p> <p>5.- Alimentaci\u00f3n L\u00f3gica: Conectar el ESP32 a la computadora mediante el cable USB para la alimentaci\u00f3n l\u00f3gica y la carga del c\u00f3digo.</p> <p>6.- Subimos el codigo a la ESP32</p> <pre><code>#define in1 32\n#define in2 33\nint var=20;\n\u00a0\nvoid setup() {\n\u00a0\n\u00a0 pinMode(in1, OUTPUT);\n\u00a0 pinMode(in2, OUTPUT);\n\u00a0 ledcAttachChannel(25, 1000, 8 , 0);\n\u00a0 Serial.begin(115200);\n\u00a0\n\u00a0\n}\n\u00a0\nvoid loop() {\n\u00a0 Serial.println(var);\n\u00a0 ledcWrite(25, var);\n\u00a0 digitalWrite(in1,1);\n\u00a0 digitalWrite(in2,0);\n\u00a0 delay(1000);\n\u00a0 var=var+20;\n\u00a0 if(var&gt;255){\n\u00a0 \u00a0 \u00a0var=var-80;\n\u00a0 } \u00a0\n\u00a0 delay(1000);\n\u00a0\n}\n</code></pre>"},{"location":"Practicas/#resultados_5","title":"Resultados","text":"<ul> <li> <p>Aceleraci\u00f3n: El motor aument\u00f3 su velocidad en pasos de 20 unidades de PWM cada 2 segundos.</p> </li> <li> <p>Desaceleraci\u00f3n/Salto: En lugar de una desaceleraci\u00f3n gradual, se observ\u00f3 un salto repentino a una velocidad menor cuando el contador var super\u00f3 255, seguido de una nueva aceleraci\u00f3n.</p> </li> <li> <p>Direcci\u00f3n: La direcci\u00f3n de giro se mantuvo fija durante todo el experimento.</p> </li> </ul>"},{"location":"Practicas/#conclusion_5","title":"Conclusion","text":"<p>La pr\u00e1ctica fue exitosa en la implementaci\u00f3n de PWM para el control de velocidad del motor DC con el ESP32. Se logr\u00f3 un control din\u00e1mico donde el motor aceler\u00f3 continuamente. El principal aprendizaje fue el uso de la funci\u00f3n ledcWrite() para modular la velocidad y la importancia de la resoluci\u00f3n de 8 bits (0-255). Sin embargo, el mecanismo implementado para manejar el exceso de velocidad (la ca\u00edda de 80 unidades) result\u00f3 en un salto brusco de velocidad, no en una desaceleraci\u00f3n progresiva y suave.</p>"},{"location":"Practicas/#practica-7-reproduccion-del-video-de-la-camara-con-codigo-de-python","title":"Practica 7 - Reproduccion del video de la camara con codigo de Python","text":""},{"location":"Practicas/#introduccion_6","title":"Introduccion","text":"<p>Esta pr\u00e1ctica se centr\u00f3 en el desarrollo de una aplicaci\u00f3n simple de visi\u00f3n por computadora utilizando Python y la librer\u00eda OpenCV (cv2). Se logr\u00f3 acceder y capturar el stream de video en tiempo real desde la c\u00e1mara web de la computadora. La finalidad fue visualizar dicho flujo de video en una ventana emergente, estableciendo as\u00ed una base fundamental para futuros proyectos de procesamiento de im\u00e1genes. Todo el proceso de codificaci\u00f3n y ejecuci\u00f3n se realiz\u00f3 dentro del entorno de Visual Studio.</p> <ul> <li>Objetivos:</li> </ul> <p>Los objetivos principales de esta pr\u00e1ctica fueron:    - </p>"},{"location":"Practicas/#marco-teorico_6","title":"Marco Teorico","text":"<ol> <li> <p>Python: Es el lenguaje de programaci\u00f3n utilizado. Se eligi\u00f3 por su simplicidad y su capacidad para manejar grandes librer\u00edas como OpenCV, siendo ideal para proyectos de Visi\u00f3n por Computadora.</p> </li> <li> <p>OpenCV (Open Source Computer Vision Library): Es la biblioteca esencial que proporcion\u00f3 las herramientas para interactuar con la c\u00e1mara.</p> </li> <li> <p><code>cv2.VideoCapture(0)</code>: Se us\u00f3 para establecer la conexi\u00f3n con la c\u00e1mara web (el \u00edndice 0).</p> </li> <li> <p><code>cv2.imshow()</code> y <code>cv2.waitKey()</code>: Funciones que se encargaron de mostrar el fotograma en una ventana y controlar la velocidad del stream y la salida del programa.</p> </li> <li> <p>Visual Studio: Fue el Entorno de Desarrollo Integrado (IDE) que facilit\u00f3 la escritura, ejecuci\u00f3n y gesti\u00f3n del c\u00f3digo Python y sus librer\u00edas.</p> </li> </ol>"},{"location":"Practicas/#procedimiento_6","title":"Procedimiento","text":"<p>Materiales y Equipo</p> <ol> <li>Hardware:</li> <li>Computadora: PC o laptop.</li> <li> <p>C\u00e1mara Web: Integrada o externa (USB).</p> </li> <li> <p>Software:</p> </li> <li>IDE: Visual Studio o Visual Studio Code (con extensi\u00f3n de Python).</li> <li>Lenguaje: Python 3.x.</li> <li>Librer\u00eda Principal: OpenCV (opencv-python), instalada mediante pip. </li> </ol> <p>Procedimiento</p> <ol> <li> <p>Primero, en caso de no tenerlo instalado, debiamos instalar Python 3.2 para empezar a programar en Visual Studio</p> </li> <li> <p>Luego en Visual Studio creamos una carpeta en Python 3.2 y empezamos a programar</p> </li> <li> <p>Se importaron las librer\u00edas cv2 y numpy. Se inicializ\u00f3 el objeto de captura de video (video = cv2.VideoCapture(0)) y se comenz\u00f3 un bucle infinito para leer continuamente los fotogramas de la c\u00e1mara.</p> </li> <li> <p>Para facilitar la detecci\u00f3n de colores bajo diferentes condiciones de luz, cada fotograma capturado (frame) se convirti\u00f3 del espacio de color BGR al espacio de color HSV (Tono, Saturaci\u00f3n, Valor) mediante la funci\u00f3n cv2.cvtColor(dibujo, cv2.COLOR_BGR2HSV).</p> </li> <li> <p>Definici\u00f3n del Rango de Color (Segmentaci\u00f3n): Se defini\u00f3 un rango de color espec\u00edfico en el espacio HSV para aislar el objeto de inter\u00e9s:</p> </li> <li> <p>L\u00edmite Inferior (bajo): [150, 80, 40]</p> </li> <li> <p>L\u00edmite Superior (alto): [255, 255, 255]</p> </li> <li> <p>Creaci\u00f3n de la M\u00e1scara: Se utiliz\u00f3 la funci\u00f3n cv2.inRange(hsv, bajo, alto) para crear una m\u00e1scara binaria. Esta m\u00e1scara solo mantuvo en color blanco los p\u00edxeles cuyo valor HSV ca\u00eda dentro del rango definido, y el resto lo estableci\u00f3 en negro.</p> </li> <li> <p>Aplicaci\u00f3n del Filtro: Se aplic\u00f3 una operaci\u00f3n AND bit a bit (cv2.bitwise_and) entre el fotograma original y la m\u00e1scara. El resultado (result) mostr\u00f3 \u00fanicamente el \u00e1rea segmentada por el color, manteniendo el fondo negro.</p> </li> <li> <p>Visualizaci\u00f3n y Cierre: Se crearon tres ventanas para monitorear el proceso:</p> </li> <li> <p>\"ORIGINAL\": El fotograma BGR capturado directamente.</p> </li> <li> <p>\"MASK\": La m\u00e1scara binaria que muestra el \u00e1rea segmentada.</p> </li> <li> <p>\"RESULTADO\": El fotograma final filtrado por color.</p> </li> </ol> <p>9.- Finalmente, se implement\u00f3 la condici\u00f3n de salida (if cv2.waitKey(1) &amp; 0xFF == ord('q'):) para cerrar el programa al presionar la tecla 'q'.</p> <ul> <li>Este es el codigo con todo incluido:</li> </ul> <pre><code>import cv2\nimport numpy as np\n\n\nvideo = cv2.VideoCapture(0)\ncx=0\ncy=0\nwhile True:\n    ret, frame = video.read()\n    if not ret:\n        break\n    dibujo = frame.copy()\n    hsv = cv2.cvtColor(dibujo, cv2.COLOR_BGR2HSV)\n    #2 variables rango alto y bajo\n\n    bajo= np.array([150,80,40], dtype=np.uint8)\n    alto= np.array([255,255,255], dtype=np.uint8)\n\n    mask = cv2.inRange(hsv,bajo,alto)\n    result= cv2.bitwise_and(frame, frame, mask=mask)\n\n    #dibujo = cv2.cvtColor(dibujo, cv2.COLOR_BGR2RGB)\n    #dibujo[0:240,0:320,1]=0\n    #dibujo[240:480,320:640,0]=0\n    #cv2.line(dibujo, (0,0),(640, 480), (0,0,255),thickness=3, lineType=cv2.LINE_AA)\n    #cv2.rectangle(dibujo, (0,0),(640, 480), (0,255,0),thickness=3, lineType=cv2.LINE_AA)\n    #cv2.circle(dibujo, (cx,cy),100, (0,255,0),thickness=3, lineType=cv2.LINE_AA)\n    #cv2.putText(dibujo, \"texto\",(320,240),cv2.FONT_HERSHEY_SIMPLEX, 2, (255,0,0),thickness=2, lineType=cv2.LINE_AA)\n    #cx=cx+1\n    #cy=cy+1\n    #mostrar imagen\n    cv2.imshow(\"ORIGINAL\",frame)\n    cv2.imshow(\"MASK\",mask)\n    cv2.imshow(\"RESULTADO\",result)\n    #Salida del bucle\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\nvideo.release()  \n</code></pre> <ol> <li>Por ultimo compilamos e iniciamos el codigo para comprobar que funciona</li> </ol>"},{"location":"Practicas/#resultados_6","title":"Resultados","text":"<ul> <li> <p>Visualizaci\u00f3n Exitosa: Se logr\u00f3 iniciar la conexi\u00f3n con la c\u00e1mara y mostrar el stream de video en una ventana gr\u00e1fica en tiempo real.</p> </li> <li> <p>Segmentaci\u00f3n por Color (HSV): El c\u00f3digo fue m\u00e1s all\u00e1 de la simple visualizaci\u00f3n, implementando la detecci\u00f3n y aislamiento de un color espec\u00edfico (rojo/magenta) mediante el uso de la conversi\u00f3n al espacio de color HSV y la funci\u00f3n cv2.inRange().</p> </li> <li> <p>Monitoreo del Proceso: Se generaron tres ventanas (\"ORIGINAL\", \"MASK\" y \"RESULTADO\") que permitieron visualizar cada etapa del procesamiento: la imagen sin filtrar, la m\u00e1scara binaria, y el resultado final de la segmentaci\u00f3n.</p> </li> </ul>"},{"location":"Practicas/#conclusion_6","title":"Conclusion","text":"<p>La pr\u00e1ctica confirm\u00f3 la utilidad de OpenCV para la adquisici\u00f3n y el filtrado de video. Se valid\u00f3 el concepto de segmentaci\u00f3n por color (HSV), que permiti\u00f3 aislar objetos bas\u00e1ndose en su tonalidad de manera m\u00e1s robusta que el espacio de color BGR. Este ejercicio sent\u00f3 la base funcional para futuras aplicaciones de visi\u00f3n por computadora, como el seguimiento autom\u00e1tico de objetos.</p> <p> </p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"}]}